Index: main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from sys import flags\r\n\r\nimport arcade\r\nfrom LevelTools import *\r\nfrom classes.Ghost import Ghost\r\nfrom classes.Pacman import Pacman\r\nfrom classes.Wall import Wall\r\nfrom classes.Coin import Coin\r\nfrom classes.Apple import Apple\r\nimport time\r\nfrom classes.Teleport import Teleport\r\n\r\nTILE = ENV_VAR_DICT[\"TILE_SIZE\"]\r\nclass PacmanGame(arcade.View):\r\n    def __init__(self, level_matrix, w_s_x=0, w_s_y=0):\r\n        self.level_matrix = level_matrix\r\n        self.w, self.h = w_s_x, w_s_y\r\n\r\n        super().__init__()\r\n        self.score = 0\r\n        self.game_over = False\r\n\r\n        self.wall_list =arcade.SpriteList()\r\n        self.coin_list =arcade.SpriteList()\r\n        self.teleport_list = arcade.SpriteList()\r\n        self.player = None\r\n        self.moving_sprites = arcade.SpriteList()\r\n        self.ghost_list = arcade.SpriteList()\r\n        self.key = None\r\n        self.fruit_list = arcade.SpriteList()\r\n        self.apple_list = arcade.SpriteList()\r\n\r\n        self.eat_ghost_mode_on = False\r\n        self.time_for_eat_mode = 0\r\n        self.eat_time = 0\r\n        self.flag_tep = False\r\n        arcade.set_background_color(arcade.color.BLACK)\r\n\r\n    def setup(self):\r\n        for i_row, row in enumerate(self.level_matrix):\r\n            for i_col, col in enumerate(self.level_matrix[i_row]):\r\n                if col == \"coin\":\r\n                    self.coin_list.append(Coin(coords_to_pixels((i_col, i_row))))\r\n                elif col == \"wall\":\r\n                    self.wall_list.append(Wall(coords_to_pixels((i_col, i_row))))\r\n                elif \"ghost\" in col:\r\n                    ghost = Ghost(ENV_VAR_DICT[col.upper()+\"_TEXTURE\"], coords_to_pixels((i_col, i_row)))\r\n                    self.ghost_list.append(ghost)\r\n                    self.moving_sprites.append(ghost)\r\n                elif col == \"pacman\":\r\n                    self.player = Pacman(coords_to_pixels((i_col, i_row)))\r\n                    self.moving_sprites.append(self.player)\r\n                elif col == 'apple':\r\n                    self.apple_list.append(Apple(coords_to_pixels((i_col, i_row))))\r\n                elif col == \"teleport\":\r\n                    self.teleport_list.append(Teleport(coords_to_pixels((i_col, i_row))))\r\n\r\n\r\n    def on_draw(self):\r\n        self.clear()\r\n\r\n        self.wall_list.draw()\r\n        self.coin_list.draw()\r\n        self.teleport_list.draw()\r\n        self.apple_list.draw()\r\n        self.moving_sprites.draw()\r\n\r\n        arcade.draw_text(f\"Score: {self.score}\", TILE_SIZE+2, TILE_SIZE//3,\r\n                         arcade.color.YELLOW, TILE_SIZE//2)\r\n        if self.game_over and not self.coin_list:\r\n            arcade.draw_text(\"YOU WIN\", self.w // 2, self.h // 2,\r\n                             arcade.color.GREEN, 50, anchor_x=\"center\")\r\n\r\n        if self.game_over and self.coin_list:\r\n            arcade.draw_text(\"GAME OVER\", self.w // 2, self.h // 2,\r\n                             arcade.color.RED, 50, anchor_x=\"center\")\r\n\r\n\r\n\r\n    def on_key_press(self, key, modifiers):\r\n        if not self.game_over:\r\n            self.player.key = key\r\n\r\n    def on_update(self, delta_time):\r\n        if self.eat_ghost_mode_on:\r\n            cur_time = time.time()\r\n            if cur_time - self.eat_time >= self.time_for_eat_mode:\r\n                self.eat_ghost_mode_on = False\r\n                self.time_for_eat_mode = 0\r\n                for ghost in self.ghost_list:\r\n                    ghost.texture = arcade.load_texture(ENV_VAR_DICT[ghost.type.upper()+\"_TEXTURE\"])\r\n\r\n        for sprite in self.moving_sprites:\r\n            if sprite.center_x % 32 - 16 == 0 and sprite.center_y % 32 -16 == 0:\r\n                if sprite.key is None:\r\n                    sprite.stop()\r\n                else:\r\n                    sprite.move()\r\n\r\n\r\n\r\n        for ghost in self.ghost_list:\r\n            ghost.update()\r\n            if arcade.check_for_collision_with_list(ghost, self.teleport_list) or arcade.check_for_collision_with_list(ghost, self.wall_list):\r\n                ghost.center_x = ghost.m_x * TILE_SIZE + 16\r\n                ghost.center_y = ghost.m_y * TILE_SIZE + 16\r\n                ghost.stop()\r\n\r\n        if arcade.check_for_collision_with_list(player:=self.player, self.wall_list):\r\n            player.center_x = player.m_x * TILE_SIZE + 16\r\n            player.center_y = player.m_y * TILE_SIZE + 16\r\n            player.stop()\r\n\r\n        if self.flag_tep and arcade.check_for_collision(self.player, self.teleport_list[0]):\r\n            self.player.center_x, self.player.center_y = self.teleport_list[1].center_x, self.teleport_list[1].center_y\r\n            self.flag_tep = False\r\n            print(self.player.center_x, self.player.center_y)\r\n\r\n        if self.flag_tep and arcade.check_for_collision(self.player, self.teleport_list[1]):\r\n            self.player.center_x, self.player.center_y = self.teleport_list[0].center_x, self.teleport_list[0].center_y\r\n            print(self.player.center_x, self.player.center_y)\r\n            self.flag_tep = False\r\n        if not arcade.check_for_collision_with_list(self.player, self.teleport_list):\r\n            self.flag_tep = True\r\n\r\n\r\n        coins_hit_list = arcade.check_for_collision_with_list(self.player, self.coin_list)\r\n        for coin in coins_hit_list:\r\n            coin.remove_from_sprite_lists()\r\n            self.score += 1\r\n\r\n        apples_hit_list = arcade.check_for_collision_with_list(self.player, self.apple_list)\r\n\r\n        for apple in apples_hit_list:\r\n            apple.remove_from_sprite_lists()\r\n            self.time_for_eat_mode += 6\r\n            for ghost in self.ghost_list:\r\n                ghost.texture = arcade.load_texture(ENV_VAR_DICT[\"EATABLE\"])\r\n            self.eat_ghost_mode_on = True\r\n            self.eat_time = time.time()\r\n\r\n\r\n\r\n        if not self.coin_list:\r\n            for sprite in self.moving_sprites:\r\n                sprite.stop()\r\n            self.game_over = True\r\n\r\n        if arcade.check_for_collision_with_list(self.player, self.ghost_list):\r\n            if self.eat_ghost_mode_on:\r\n                ghost_hit_list = arcade.check_for_collision_with_list(self.player, self.ghost_list)\r\n                for ghost in ghost_hit_list:\r\n                    ghost.remove_from_sprite_lists()\r\n            else:\r\n                for sprite in self.moving_sprites:\r\n                    sprite.stop()\r\n                self.game_over = True\r\n        self.player.update()\r\n\r\n\r\n\r\ndef main():\r\n    level_matrix = load_level_from_txt()\r\n    w_s_x, w_s_y = len(level_matrix[0]) * ENV_VAR_DICT['TILE_SIZE'], len(level_matrix) * ENV_VAR_DICT['TILE_SIZE']\r\n    window = arcade.Window(w_s_x, w_s_y, \"PACMAN GAME\", resizable=True)\r\n    game = PacmanGame(level_matrix, w_s_x, w_s_y)\r\n\r\n    game.setup()\r\n    window.show_view(game)\r\n    arcade.run()\r\n\r\nif __name__ == \"__main__\":\r\n    main()
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/main.py b/main.py
--- a/main.py	(revision 667f34769248abc693cb630a6ab1bb9594898fb8)
+++ b/main.py	(date 1770153238009)
@@ -34,6 +34,11 @@
         self.time_for_eat_mode = 0
         self.eat_time = 0
         self.flag_tep = False
+
+        self.ghost_barrier_list = None  # Для A* барьеров призраков
+        self.ghost_paths = {}  # Словарь путей: {ghost_id: path}
+
+
         arcade.set_background_color(arcade.color.BLACK)
 
     def setup(self):
@@ -54,7 +59,13 @@
                     self.apple_list.append(Apple(coords_to_pixels((i_col, i_row))))
                 elif col == "teleport":
                     self.teleport_list.append(Teleport(coords_to_pixels((i_col, i_row))))
-
+        self.ghost_barrier_list = arcade.AStarBarrierList(
+            self.ghost_list[0],  # Используем player для проверки видимости (или dummy sprite)
+            self.wall_list,
+            ENV_VAR_DICT["TILE_SIZE"],
+            0, self.w,  # left, right, bottom, top
+            0, self.h
+        )
 
     def on_draw(self):
         self.clear()
@@ -81,7 +92,12 @@
         if not self.game_over:
             self.player.key = key
 
+    def astar_ghost_pass(self, ghost):
+
     def on_update(self, delta_time):
+
+
+        self.ghost_paths[id(ghost)] = path
         if self.eat_ghost_mode_on:
             cur_time = time.time()
             if cur_time - self.eat_time >= self.time_for_eat_mode:
Index: classes/Ghost.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import arcade, random\r\nfrom .Character import Character\r\nfrom LevelTools import *\r\n\r\nclass Ghost(Character):\r\n    def __init__(self, texture, cords):\r\n        self.type = texture[4:-4].lower()\r\n        super().__init__(texture, ENV_VAR_DICT[\"GHOST_SCALE\"], cords, ENV_VAR_DICT['GHOST_MOVE_SPEED'], ENV_VAR_DICT['GHOST_ANGLE'])\r\n        self.ghost_delta_tile = 0\r\n\r\n    def update(self):\r\n        self.ghost_delta_tile += 0.1\r\n        if int(self.ghost_delta_tile) == ENV_VAR_DICT['GHOST_DELTA_TIME']:\r\n            self.ghost_delta_tile = 0\r\n            self.key = random.choice([arcade.key.UP,\r\n                                                   arcade.key.DOWN,\r\n                                                   arcade.key.LEFT,\r\n                                                   arcade.key.RIGHT,])\r\n        super().update()
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/classes/Ghost.py b/classes/Ghost.py
--- a/classes/Ghost.py	(revision 667f34769248abc693cb630a6ab1bb9594898fb8)
+++ b/classes/Ghost.py	(date 1770153206169)
@@ -16,4 +16,28 @@
                                                    arcade.key.DOWN,
                                                    arcade.key.LEFT,
                                                    arcade.key.RIGHT,])
-        super().update()
\ No newline at end of file
+        super().update()
+
+    def update_ai_path(self, game):
+        """Движение по A* пути"""
+        path = game.ghost_paths.get(id(self))
+        if path and len(path) > 1:
+            next_point = path[0]  # Следующая точка пути
+            # Движение к точке (grid-based)
+            dx = next_point[0] - self.center_x
+            dy = next_point[1] - self.center_y
+            dist = (dx ** 2 + dy ** 2) ** 0.5
+
+            if dist < 5:  # Достигли точки — убираем её
+                path.pop(0)
+            else:
+                # Нормализованное движение
+                self.center_x += (dx / dist) * self.speed * 1 / 60
+                self.center_y += (dy / dist) * self.speed * 1 / 60
+
+
+        if (arcade.check_for_collision_with_list(self, game.wall_list) or
+                arcade.check_for_collision_with_list(self, game.teleport_list)):
+            self.center_x = self.m_x * ENV_VAR_DICT["TILE_SIZE"] + ENV_VAR_DICT["TILE_SIZE"] // 2
+            self.center_y = self.m_y * ENV_VAR_DICT["TILE_SIZE"] + ENV_VAR_DICT["TILE_SIZE"] // 2
+            self.stop()
\ No newline at end of file
